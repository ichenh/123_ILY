<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ¨æ€ç²’å­äº¤äº’ç‰¹æ•ˆ (æ‰‹åŠ¿è¯†åˆ«)</title>
    <style>
        /* style.css */

/* å…¨å±€é‡ç½® */
body {
    margin: 0;
    overflow: hidden;
    background-color: #000;
    color: #fff;
    font-family: sans-serif;
}

/* Three.js canvas å®¹å™¨ */
canvas {
    display: block;
}

/* éšè— MediaPipe ç”¨äºè¾“å…¥çš„ video å…ƒç´  */
#input-video {
    display: none;
}

/* å…¨å±æŒ‰é’®æ ·å¼ */
#fs-btn {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 8px 15px;
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
    border: 2px solid #fff;
    border-radius: 5px;
    cursor: pointer;
    z-index: 1000;
    user-select: none;
    font-size: 14px;
    opacity: 0.8;
    transition: opacity 0.3s;
}

#fs-btn:hover {
    opacity: 1;
}

/* ç§»åŠ¨ç«¯å¯åŠ¨è¦†ç›–å±‚æ ·å¼ */
#start-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    color: #fff;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    text-align: center;
}

#start-btn {
    padding: 15px 30px;
    margin-top: 20px;
    font-size: 18px;
    background: #ff69b4; /* çˆ±å¿ƒç²‰è‰² */
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(255, 105, 180, 0.4);
    transition: background 0.3s;
}

#start-btn:hover {
    background: #ff4d9a;
}

    </style>

    
</head>
<body>

    <div id="start-overlay" style="display: none;">
        <h2>ğŸ’– ç²’å­äº’åŠ¨ç‰¹æ•ˆ ğŸ’–</h2>
        <p>æ£€æµ‹åˆ°ç§»åŠ¨è®¾å¤‡ã€‚ç‚¹å‡»å¼€å§‹æŒ‰é’®ä»¥å¯ç”¨æ‘„åƒå¤´è¿›è¡Œæ‰‹åŠ¿äº’åŠ¨ã€‚</p>
        <button id="start-btn">
            ç‚¹å‡»å¼€å§‹ (è¯·æ±‚æ‘„åƒå¤´æƒé™)
        </button>
    </div>

    <div id="fs-btn">Fullscreen</div>

    <video id="input-video" style="display: none;" autoplay playsInline></video>

    <script type="module">
// --- å¯¼å…¥ä¾èµ– ---
import * as THREE from "https://esm.sh/three@0.160.0";
import { FontLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/FontLoader.js";
import { TextGeometry } from "https://esm.sh/three@0.160.0/examples/jsm/geometries/TextGeometry.js";
import { MeshSurfaceSampler } from "https://esm.sh/three@0.160.0/examples/jsm/math/MeshSurfaceSampler.js";

// MediaPipe å¯¼å…¥æ”¹å›ä½¿ç”¨ CDN
import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js"; 


// --- é…ç½®ä¸å…¨å±€å˜é‡ ---
const CONFIG = {
  particleCount: 10000, 
  particleSize: 0.12, 
  CONFESSION_THRESHOLD_MS: 100, // âš ï¸ å…³é”®ä¿®æ”¹ 1: å°†å»¶è¿Ÿä» 300ms ç¼©çŸ­åˆ° 100ms
  MAX_ROTATION_Y: Math.PI / 4,        
  ROTATION_SMOOTHING: 0.05,           
  ASPECT_RATIO_THRESHOLD: 1.2,
  HEART_PARTICLE_START: 2000, 
  HEART_PARTICLE_END: 8000,   
  HEART_PULSE_SPEED: 5.0, 
  HEART_PULSE_MIN: 0.9,   
  HEART_PULSE_MAX: 1.1,   
  colors: {
    text: 0x00ffff,
    love: 0xff69b4,
    balloon: [0xff4d4d, 0x4dff4d, 0x4d4dff, 0xffff4d, 0xff4dff]
  }
};

const LAYOUT_CONFIG = {
    HORIZONTAL: {
        I: { x: -10.5, y: 0 }, 
        H: { x: 0, y: 0 },
        U: { x: 10.5, y: 0 } 
    },
    VERTICAL: {
        I: { x: 0, y: 9.5 }, 
        H: { x: 0, y: 0 },
        U: { x: 0, y: -9.5 } 
    }
};

let scene, camera, renderer, particles, particleGeo;
let targetPositions = new Float32Array(CONFIG.particleCount * 3);
let originalHeartPositions = null; 
let balloons = []; 
let handLandmarker = undefined;
let video = null;
let lastGesture = -1;
let loadedFont = null;
let isConfessionMode = false;
let cameraInitialized = false; 

let targetRotationY = 0;
let currentRotationY = 0;
let confessionTimer = null;
let lastDetectionTime = 0;
let currentScaleFactor = 1.0; 


function getLayoutMode() {
    return window.innerWidth / window.innerHeight >= CONFIG.ASPECT_RATIO_THRESHOLD ? 'HORIZONTAL' : 'VERTICAL';
}

function isMobileView() {
    return window.innerWidth / window.innerHeight < CONFIG.ASPECT_RATIO_THRESHOLD;
}

// =========================================================
// === ğŸš€ å¯åŠ¨å…¥å£ ===
// =========================================================
async function init() {
    createUIBindings();
    initThree();
    await initMediaPipe();
    await loadFont();
    animate();

    if (isMobileView()) {
        console.log("æ£€æµ‹åˆ°çª„å±è®¾å¤‡ï¼Œä½¿ç”¨ Mobile å¯åŠ¨æµç¨‹ã€‚");
        initMobile();
    } else {
        console.log("æ£€æµ‹åˆ°å®½å±è®¾å¤‡ï¼Œä½¿ç”¨ Desktop å¯åŠ¨æµç¨‹ã€‚");
        initDesktop();
    }
}

// --- ğŸ’»/ğŸ“± è®¾å¤‡å¯åŠ¨æµç¨‹ ---

function initDesktop() {
    setupCamera();
}

function initMobile() {
    const overlay = document.getElementById('start-overlay');
    const startBtn = document.getElementById('start-btn');
    
    if (overlay) overlay.style.display = 'flex'; 
    
    if (startBtn) {
        startBtn.onclick = () => {
            if (!cameraInitialized) {
                setupCamera();
            }
        };
    }
}

function createUIBindings() {
    video = document.getElementById('input-video');

    const fsBtn = document.getElementById('fs-btn');
    if (fsBtn) {
        fsBtn.onclick = () => {
            if (!document.fullscreenElement) document.body.requestFullscreen();
            else document.exitFullscreen();
        };
    }
}

// --- 2. Three.js åœºæ™¯æ­å»º ---
function initThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    function updateCameraZ() {
        const aspectRatio = window.innerWidth / window.innerHeight;
        camera.position.z = 20 + Math.max(0, 1 / aspectRatio - 0.5) * 10;
    }
    updateCameraZ();

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 0.8);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    particleGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    for (let i = 0; i < CONFIG.particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 60;
    }
    particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particleMat = new THREE.PointsMaterial({
        color: CONFIG.colors.text,
        size: CONFIG.particleSize,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
    });

    particles = new THREE.Points(particleGeo, particleMat);
    scene.add(particles); 
    
    updateTargetPositionsToRandom();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateCameraZ(); 
        
        if (isConfessionMode) {
            triggerConfession(true); 
        }
    });
}

// --- 3. èµ„æºåŠ è½½ ---
async function loadFont() {
  const loader = new FontLoader();
  return new Promise(resolve => {
    // å­—ä½“æ–‡ä»¶ä»ä½¿ç”¨ CDNï¼Œæ‚¨å¯ä»¥è€ƒè™‘å°†å…¶ä¹Ÿæœ¬åœ°åŒ–
    loader.load('https://esm.sh/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
      loadedFont = font;
      resolve();
    });
  });
}

// --- 4. MediaPipe åˆå§‹åŒ– (CDN æ•…éšœè½¬ç§»æœºåˆ¶) ---
async function initMediaPipe() {
  
  const CDN_WASM_PATH = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm";
  const LOCAL_PATH = "./models";
  
  let filesetResolverPath = CDN_WASM_PATH;
  // MediaPipe æ¨¡å‹ GCS åŸå§‹åœ°å€
  let modelAssetPath = `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`;

  // --- æ¢æµ‹ CDN æ˜¯å¦å¯ç”¨ ---
  try {
    // å°è¯•é€šè¿‡ Fetch API è®¿é—® WASM è·¯å¾„ä¸‹çš„å°æ–‡ä»¶æ¥åˆ¤æ–­è¿é€šæ€§
    const response = await fetch(`${CDN_WASM_PATH}/vision_wasm_internal.js`);
    if (!response.ok) {
        // å¦‚æœçŠ¶æ€ç ä¸æ˜¯ 2xx, è§†ä¸ºå¤±è´¥
        throw new Error("CDN status not OK or file not found.");
    }
    console.log("âœ… MediaPipe CDN è¿é€šæ€§è‰¯å¥½ï¼Œä½¿ç”¨ CDN è·¯å¾„ã€‚");
    
  } catch (error) {
    // å¦‚æœ Fetch å¤±è´¥ï¼ˆç½‘ç»œé”™è¯¯ã€CORS æˆ– 404/500 ç­‰ï¼‰
    console.warn("âŒ MediaPipe CDN è®¿é—®å¤±è´¥æˆ–è¢«é˜»æ­¢ï¼Œåˆ‡æ¢åˆ°æœ¬åœ°è·¯å¾„ï¼", error);
    filesetResolverPath = LOCAL_PATH;
    modelAssetPath = `${LOCAL_PATH}/hand_landmarker.task`;
  }
  
  // --- ä½¿ç”¨ç¡®å®šçš„è·¯å¾„åˆå§‹åŒ– ---
  const vision = await FilesetResolver.forVisionTasks(filesetResolverPath); 
  
  handLandmarker = await HandLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath: modelAssetPath, // ä½¿ç”¨ç¡®å®šçš„æ¨¡å‹è·¯å¾„
      delegate: "GPU"
    },
    runningMode: "VIDEO",
    numHands: 1
  });
  console.log("MediaPipe æ¨¡å‹å·²åˆå§‹åŒ–ï¼Œç­‰å¾…æ‘„åƒå¤´å¯åŠ¨...");
}

// --- 5. æ‘„åƒå¤´è®¾ç½® ---
function setupCamera() {
  const overlay = document.getElementById('start-overlay');
  if (overlay) overlay.style.display = 'none';
  
  if (!video) {
    console.error("Video element not found.");
    return;
  }
  
  navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
    video.srcObject = stream;
    video.addEventListener("loadeddata", predictWebcam);
    cameraInitialized = true;
  }).catch(err => {
     console.error("æ— æ³•è®¿é—®æ‘„åƒå¤´: ", err);
     
     let errorMessage = "æ‘„åƒå¤´æƒé™è·å–å¤±è´¥ã€‚";
     
     if (err.name === "NotAllowedError" || err.name === "SecurityError") {
         errorMessage += "\n\nè¯·æ£€æŸ¥æ‚¨çš„æµè§ˆå™¨æƒé™è®¾ç½®ï¼Œå¹¶ç¡®è®¤æ‚¨å·²ç‚¹å‡»äº†â€œå¼€å§‹â€æŒ‰é’®æ¥æˆäºˆæƒé™ã€‚";
     } else if (err.name === "NotFoundError") {
         errorMessage += "\n\næœªæ‰¾åˆ°å¯ç”¨çš„æ‘„åƒå¤´è®¾å¤‡ã€‚";
     } else {
         errorMessage += `\n\nå‡ºç°æœªçŸ¥é”™è¯¯ (${err.name})ï¼Œè¯·æ£€æŸ¥ Consoleã€‚`;
     }

     alert(errorMessage);
  });
}

// --- MediaPipe é¢„æµ‹å¾ªç¯ (åªå¤„ç†æ‰‹åŠ¿å’Œæ—‹è½¬) ---
async function predictWebcam() {
  if (handLandmarker && video.readyState >= 2) { 
    const now = performance.now();
    const results = await handLandmarker.detectForVideo(video, now);
    lastDetectionTime = now;
    
    if (results.landmarks.length > 0) {
      const landmarks = results.landmarks[0];
      const fingerCount = countFingers(landmarks);
      handleGesture(fingerCount);
      
      const wristX = landmarks[0].x; 
      targetRotationY = (0.5 - wristX) * 2 * CONFIG.MAX_ROTATION_Y;
      
    } else {
      handleGesture(-1); 
      targetRotationY = 0; 
    }
  }
  requestAnimationFrame(predictWebcam);
}

// --- æ‰‹æŒ‡è®¡æ•° (åˆ¤æ–­æ‰‹åŠ¿) ---
function countFingers(landmarks) {
  const tips = [4, 8, 12, 16, 20];
  const pips = [3, 6, 10, 14, 18];
  let count = 0;
  
  const thumbTip = landmarks[4];
  const thumbIp = landmarks[3];
  const pinkyMcp = landmarks[17];
  
  const distTip = Math.hypot(thumbTip.x - pinkyMcp.x, thumbTip.y - pinkyMcp.y);
  const distIp = Math.hypot(thumbIp.x - pinkyMcp.x, thumbIp.y - pinkyMcp.y);
  
  if (distTip > distIp * 1.1) count++;

  for (let i = 1; i < 5; i++) {
    if (landmarks[tips[i]].y < landmarks[pips[i]].y) count++; 
  }
  return count;
}

// --- äº¤äº’é€»è¾‘æ ¸å¿ƒ (å·²ä¿®æ”¹) ---
function handleGesture(count) {
  
  // å‘Šç™½æ¨¡å¼é˜²æŠ–åŠ¨é€»è¾‘
  if (count === 5) {
      if (!isConfessionMode) { // å¦‚æœä¸æ˜¯å‘Šç™½æ¨¡å¼ï¼Œæ‰æ£€æŸ¥å’Œè®¡æ—¶
          if (!confessionTimer) {
              confessionTimer = setTimeout(() => {
                  if (lastGesture === 5) {
                       triggerConfession(false); 
                       // âš ï¸ å…³é”®ä¿®æ”¹ 2: æˆåŠŸè§¦å‘å‘Šç™½æ¨¡å¼åï¼Œç«‹å³è®¾ç½® lastGesture
                       lastGesture = 5; 
                  }
                  confessionTimer = null;
              }, CONFIG.CONFESSION_THRESHOLD_MS);
          }
      }
      if (isConfessionMode) return; 
  } else {
      // å¦‚æœä¸æ˜¯ 5 æŒ‡ï¼Œå–æ¶ˆè®¡æ—¶å™¨
      if (confessionTimer) {
          clearTimeout(confessionTimer);
          confessionTimer = null;
      }
      // å¦‚æœå¤„äºå‘Šç™½æ¨¡å¼ï¼Œä½†æ‰‹åŠ¿ä¸æ˜¯ 5 ä¹Ÿä¸æ˜¯ 0ï¼Œåˆ™ä¿æŒå½“å‰çŠ¶æ€ï¼Œä½†é‡ç½®ç¼©æ”¾
      if (isConfessionMode && count !== 0) {
         currentScaleFactor = 1.0; 
         return;
      }
  }
  
  // å¤„ç†å…¶ä»–æ‰‹åŠ¿å’Œæ‰‹åŠ¿ä¸¢å¤±
  if (count === lastGesture) return;
  
  if (count !== -1) {
    lastGesture = count;
  } else {
    // åªæœ‰å½“ count=-1 ä¸” lastGesture != -1 æ—¶æ‰é‡ç½®åœºæ™¯
    if (lastGesture !== -1) {
        resetScene();
        lastGesture = -1; // ç¡®ä¿ä¸‹æ¬¡æ£€æµ‹åˆ°æ‰‹åŠ¿æ—¶èƒ½æ­£ç¡®æ›´æ–°
    }
    return;
  }
  
  if (count === 0) {
    resetScene();
  } else if (count >= 1 && count <= 3) {
    isConfessionMode = false;
    clearBalloons();
    particles.material.color.setHex(CONFIG.colors.text);
    currentScaleFactor = 1.0; 
    sampleTextToParticles(count.toString(), 0, CONFIG.particleCount, 0, 0); 
  } 
}

function resetScene() {
  isConfessionMode = false;
  clearBalloons();
  particles.material.color.setHex(CONFIG.colors.text);
  updateTargetPositionsToRandom();
  currentScaleFactor = 1.0;
  originalHeartPositions = null;
  targetRotationY = 0; 
}

function triggerConfession(forceRepositioning) {
  if (isConfessionMode && !forceRepositioning) return;
  
  isConfessionMode = true;
  particles.material.color.setHex(CONFIG.colors.love);
  
  const mode = getLayoutMode();
  const config = LAYOUT_CONFIG[mode];
  
  let currentIndex = 0;
  
  // I 
  currentIndex = sampleTextToParticles("I", currentIndex, CONFIG.HEART_PARTICLE_START, config.I.x, config.I.y); 
  
  // Heart 
  currentIndex = generateHeartShape(currentIndex, CONFIG.HEART_PARTICLE_END - CONFIG.HEART_PARTICLE_START, config.H.y); 
  
  // U 
  sampleTextToParticles("U", currentIndex, CONFIG.particleCount - currentIndex, config.U.x, config.U.y); 
  
  if (!forceRepositioning) {
    spawnBalloonsAndFlowers();
  }
  
  saveOriginalHeartPositions();
}

function saveOriginalHeartPositions() {
    const start = CONFIG.HEART_PARTICLE_START * 3;
    const end = CONFIG.HEART_PARTICLE_END * 3;
    
    // ä»…ä¿å­˜å¿ƒå½¢éƒ¨åˆ†çš„ targetPositions
    originalHeartPositions = targetPositions.slice(start, end);
}

function sampleTextToParticles(text, startIndex, count, xOffset, yOffset) {
  if (!loadedFont || count <= 0) return startIndex;

  const geometry = new TextGeometry(text, {
    font: loadedFont,
    size: 5,
    height: 0.2,
    curveSegments: 24,
    bevelEnabled: true,
    bevelThickness: 0.1,
    bevelSize: 0.05,
    bevelSegments: 4
  });

  geometry.center();

  const material = new THREE.MeshBasicMaterial();
  const mesh = new THREE.Mesh(geometry, material);
  const sampler = new MeshSurfaceSampler(mesh).build(); 
  const tempPosition = new THREE.Vector3();

  for (let i = 0; i < count; i++) {
    const idx = (startIndex + i) * 3;
    sampler.sample(tempPosition);
    
    targetPositions[idx] = tempPosition.x + xOffset;
    targetPositions[idx + 1] = tempPosition.y + yOffset; 
    targetPositions[idx + 2] = tempPosition.z;
  }
  
  geometry.dispose();
  material.dispose();
  
  return startIndex + count;
}

function generateHeartShape(startIndex, count, yOffset) {
  const scale = 0.3; 
  
  for (let i = 0; i < count; i++) {
     const idx = (startIndex + i) * 3;
     
     let t = Math.random() * Math.PI * 2;
     let r = Math.sqrt(Math.random()); 
     
     let x = 16 * Math.pow(Math.sin(t), 3);
     let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
     
     x = x * scale * r;
     y = y * scale * r;

     targetPositions[idx] = x;
     targetPositions[idx + 1] = y + 1 + yOffset; 
     targetPositions[idx + 2] = (Math.random() - 0.5) * 2; 
  }
  return startIndex + count;
}

function updateTargetPositionsToRandom() {
  for (let i = 0; i < CONFIG.particleCount * 3; i++) {
    targetPositions[i] = (Math.random() - 0.5) * 80;
  }
}

function spawnBalloonsAndFlowers() {
  for (let i = 0; i < 60; i++) {
    const isBalloon = Math.random() > 0.4;
    const color = CONFIG.colors.balloon[Math.floor(Math.random() * CONFIG.colors.balloon.length)];
    const obj = new THREE.Group();
    
    if (isBalloon) {
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 32), new THREE.MeshPhongMaterial({ color: color, shininess: 120 }));
      const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -0.6, 0), new THREE.Vector3(0, -2.5, 0)]);
      const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xaaaaaa }));
      obj.add(sphere);
      obj.add(line);
    } else {
      const center = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
      obj.add(center);
      for(let j=0; j<6; j++) {
        const petal = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff69b4 }));
        const angle = (j / 6) * Math.PI * 2;
        petal.position.set(Math.cos(angle)*0.35, Math.sin(angle)*0.35, 0);
        obj.add(petal);
      }
    }
    
    obj.position.set((Math.random()-0.5)*40, -25 - Math.random()*20, (Math.random()-0.5)*20);
    obj.userData = { speed: 0.1 + Math.random() * 0.2, sway: Math.random() * 0.05, swayOffset: Math.random() * 100 };
    scene.add(obj);
    balloons.push(obj);
  }
}

function clearBalloons() {
  balloons.forEach(b => scene.remove(b));
  balloons = [];
}

// --- 8. åŠ¨ç”»å¾ªç¯ (çˆ±å¿ƒè·³åŠ¨) ---
function animate() {
  requestAnimationFrame(animate);
  const time = Date.now() * 0.001;
  const positions = particles.geometry.attributes.position.array;
  
  // 1. çˆ±å¿ƒè‡ªåŠ¨è·³åŠ¨é€»è¾‘
  if (isConfessionMode && originalHeartPositions) {
      const start = CONFIG.HEART_PARTICLE_START * 3;
      const end = CONFIG.HEART_PARTICLE_END * 3;
      const count = (CONFIG.HEART_PARTICLE_END - CONFIG.HEART_PARTICLE_START) * 3;
      
      // ä½¿ç”¨ä¸‰è§’å‡½æ•°ç”Ÿæˆè„‰å†²ç¼©æ”¾å€¼
      const pulse = Math.sin(time * CONFIG.HEART_PULSE_SPEED) * 0.5 + 0.5; // [0, 1]
      const desiredScale = THREE.MathUtils.lerp(CONFIG.HEART_PULSE_MIN, CONFIG.HEART_PULSE_MAX, pulse);
      
      // å¹³æ»‘æ›´æ–°å½“å‰ç¼©æ”¾å› å­
      currentScaleFactor += (desiredScale - currentScaleFactor) * 0.1;

      // åº”ç”¨ç¼©æ”¾
      for (let i = 0; i < count; i += 3) {
          targetPositions[start + i] = originalHeartPositions[i] * currentScaleFactor;
          targetPositions[start + i + 1] = originalHeartPositions[i + 1] * currentScaleFactor;
      }
  }

  // 2. åœºæ™¯æ—‹è½¬å¹³æ»‘è¿‡æ¸¡
  currentRotationY += (targetRotationY - currentRotationY) * CONFIG.ROTATION_SMOOTHING;
  particles.rotation.y = currentRotationY;
  balloons.forEach(b => b.rotation.y = currentRotationY);
  
  const lerpSpeed = 0.12; 

  // 3. ç²’å­å‘ç›®æ ‡ä½ç½®ç§»åŠ¨ (Lerpæ’å€¼)
  for (let i = 0; i < CONFIG.particleCount; i++) {
    const ix = i * 3;
    const iy = i * 3 + 1;
    const iz = i * 3 + 2;

    const noiseAmp = isConfessionMode ? 0.03 : 0.01;
    
    positions[ix] += (targetPositions[ix] - positions[ix]) * lerpSpeed + (Math.random()-0.5)*noiseAmp;
    positions[iy] += (targetPositions[iy] - positions[iy]) * lerpSpeed + (Math.random()-0.5)*noiseAmp;
    positions[iz] += (targetPositions[iz] - positions[iz]) * lerpSpeed + (Math.random()-0.5)*noiseAmp;
  }
  
  particles.geometry.attributes.position.needsUpdate = true;
  
  // 4. æ°”çƒä¸Šå‡åŠ¨ç”»
  if (balloons.length > 0) {
    balloons.forEach(b => {
      b.position.y += b.userData.speed;
      b.position.x += Math.sin(time * 2 + b.userData.swayOffset) * b.userData.sway;
      b.rotation.z = Math.sin(time + b.userData.swayOffset) * 0.1;
      if (b.position.y > 25) b.position.y = -25;
    });
  }

  renderer.render(scene, camera);
}

// å¯åŠ¨åº”ç”¨ç¨‹åº
init();
    </script>
</body>
</html>